\chapter{Verfahren}\label{ch:verfahren}


\section{Logging}\label{sec:logging-verfahren}

\subsection{Standardbibliotheken aus verschiedenen Sprachen}\label{subsec:standards-aus-verschiedenen-sprachen}

\subsubsection{Java}\label{subsubsec:java}
\textcolor{blue}{
    Die Standardbibliothek bietet seit Java-Version 1.4 ein Logging-Framework.
    Dieses Paket enthält unter anderem einen Logger.
    Dieser kann durch den Import \enquote{\texttt{import java.util.logging.Logger}} genutzt werden.
    Um einen Logger zu nutzen, muss er auch initialisiert werden.
    Hierfür wird der Logger mit dem Klassennamen als Parameter, der nutzenden Klasse, erstellt oder der entsprechende Logger gefunden:
    \\
    \\
    \hspace*{10mm}
    \texttt{\textbf{private static final} Logger LOGGER =
        \\
        \hspace*{30mm}Logger.getLogger(classname.\textbf{class}.getName());}
    \\
    \\
    Um eine Nachricht mit dem Logger zu erstellen, muss die Methode entsprechend zu dem Loglevel genutzt werden.
    Für eine informelle Nachricht wird die Methode \texttt{info()} genutzt, beispielsweise:
    \\
    \\
    \hspace*{10mm}
    \texttt{LOGGER.info(\enquote{Loggername: } + LOGGER.getName());}
    \\
    \\
    Hierbei muss der Logger mindestens das Level INFO konfiguriert haben, welches als Standardebene eingestellt ist.
    Hierdurch entsteht folgender Log mit path als Variable für den Package- und Klassenname:
    \\
    \\
    \hspace*{10mm}
    \texttt{Jun 23, 2022 1:19:30 PM path main INFO: Loggername: path}
    \\
    \\
    \\
    Die Nachrichten können auch über eine allgemeinere Methode erstellt werden.
    Diese nennt sich \texttt{log()} und nimmt als Parameter das Loglevel und die Nachricht an.
    Sowie ein Objekt, welches protokolliert werden soll.
    Es können Objekt wie Exceptions gespeichert werden.
    Um diese Methode nutzen zu können, muss ein weiterer Import gesetzt sein \enquote{\texttt{import java.util.logging.Level}}.
    Denn es werden die statischen Einträge der Levelklasse genutzt.
    \\
    \\
    \hspace*{10mm}
    \texttt{LOGGER.log(Level.SEVERE, \enquote{Eine Exception ist aufgetreten}, ex)}
    \\
    \\
    Hierbei entsteht eine Nachricht in gleichem Format:
    \\
    \\
    \hspace*{10mm}
    \texttt{Jun 23, 2022 1:19:31 PM path main SEVERE: Eine Exception
    \\
    \hspace*{30mm} ist aufgetreten.}
    \\
    \\
    Vorher wurde bereits Log4J, welches im Verlauf erläutert wird, entwickelt, weshalb ein starker Vergleich gezogen wurde.
    Der Standard aus Java ist nicht kompatibel mit Log4J.
    Des Weiteren ist es nicht so leistungsstark wie Log4J.
    \\
    \\
    Das Logging aus Java hat verschiedene Loglevel, die den Schwierigkeitsgrad des Logs zeigen.
    Diese heißen SEVERE, WARNING, INFO, CONFIG, FINE, FINER und FINEST.
    Je nach Loglevel werden die Nachrichten protokolliert oder ignoriert.
    Falls der Logger mit dem Loglevel WARNING konfiguriert wurde, wird die Nachricht mit Level INFO ignoriert.
    Daher kann unnötiger Aufwand entstehen, falls eine Nachricht, die aufwändig aufgebaut wird, nicht geschrieben wird, jedoch vorher schon eine Variable ausgewertet hat.
    Im diesen Aufwand zu verringern wurde die Methode boolean isLoggable(Level level) der Bibliothek hinzugefügt.
    Diese wertet den Ausdruck in der Log-Nachricht erst aus, falls die Nachricht geloggt werden darf.
    Eine weitere Möglichkeit den Aufwand zu verringern gibt es seit Java-Version 8.
    Hier wurden Lambda-Ausdrücke eingeführt, um den Programmcode in einem Block zusammen erst auszuführen, falls das Logging-Framework den Block ausführen soll.
    \\
    \\
    Das Logging-Framework enthält als Komponente einen Handler, der die geloggten Nachrichten an einen bestimmten Zielort speichert.
    Der KonsolenHandler schreibt die geloggten Nachrichten in die Konsole.
    Der FileHandler speichert die Logs in Dateien.
    Es gibt noch weitere Handler, die für das Speichern der Daten genutzt werden können.
    \\
    Eine weitere Komponente des Logging-Frameworks ist ein Formatter.
    Jedem Handler ist ein Formatter zugeordnet.
    Es wird unterschieden zwischen SimpleFormatter und XMLFormatter.
    Der SimpleFormatter wird genutzt, um die Logs für den Menschen einfach lesbar zu machen.
    Für den FileHandler ist der XMLFormatter standardisiert.
}\autocite{rheinwerk, examples}

\subsubsection{JavaScript}\label{subsubsec:javascript}
\textcolor{blue}{
    Bei der Entwicklung einer Webanwendung können die Fehlermeldung in der Konsole ausgegeben werden.
    Bei veröffentlichtem Code ist die Konsole nicht verfügbar.
    Daher wird die Möglichkeit genutzt, die Fehlermeldungen bei dem Client zu sammeln und an einen Server zu senden, wo diese Logs auszuwerten sind.
    Auf der Konsole können mehrere Methoden verwendet werden, die den verschiedenen Logleveln entsprechen.
    \\
    Für JavaScript gibt es vier Loglevel.
    Das Geringste ist für Klartext und nutzt die Methode \enquote{log()}.
    Das nächste Level ist Info mit der Methode \enquote{info()}.
    Außerdem gibt es wie bei anderen Log-Frameworks Warn und Error mit \enquote{warn()} und \enquote{error()}.
    Mit diesen Aufrufen werden die Nachrichten entsprechend unterlegt, entsprechend dem Level.
    Hierfür werden die Methoden wie folgt aufgerufen:
    \\
    \\
    \hspace*{10mm}
    \texttt{console.log(msg)}
}\autocite{stackify}

\subsubsection{Python}\label{subsubsec:python}
\textcolor{blue}{
    In der Standardbibliothek von Python ist ein Logging-Modul enthalten.
    Dieses kann über den Import \enquote{\texttt{import logging}} genutzt werden und hat wie andere Loggingverfahren eine Logger, Handler, Filter und Formatter als Klassen in diesem Paket.
    Der Logger wird, wie in anderen Programmiersprachen, nicht direkt initialisiert, sondern über die Methode \texttt{getLogger(\_\_name\_\_)} den aktuellen Logger zurückgegeben.
    Der Logger wird direkt im Code verwendet und gibt die Informationen an den Handler weiter.
    Dieser sendet die Log-Nachrichten an den Zielort, beispielsweise eine Datei.
    Die Klasse Filter bietet die Möglichkeit, zu filtern, ob ein Datensatz protokolliert werden soll.
    Der Formatter erzeugt das Layout der Logs.
    \\
    Wie auch bei den anderen Log-Verfahren gibt es verschiedene Schwierigkeitsgrade mit entsprechender Methode, die auf dem Logger-Objekt aufgerufen wird.
    \\
    \begin{figure}[h]
        \centering
        \textcolor{blue}{
            \begin{tabular}[h]{|p{1.5cm}|p{5cm}|p{6cm}|}
                \rowcolor{gray!50}
                \hline
                Level    & Methode                       & Nutzung                                                                        \\
                \hline
                Critical & critical(msg, args, kwargs)   & schwerwiegendes Problem liegt vor                                              \\
                \hline
                Error    & error(msg, args, kwargs)      & ein Problem ist aufgetreten, sodass eine Funktion nicht ausgeführt werden kann \\
                \hline
                Warning  & warning(msg, args, kwargs)    & eine unerwartete Situation oder ein zukünftiges Problem                        \\
                \hline
                Info     & info(msg, args, kwargs)       & Anwendung läuft ordnungsgemäß                                                  \\
                \hline
                Debug    & debug(msg, args, kwargs)      & Problemdiagnose                                                                \\
                \hline
                Notset   & log(level, msg, args, kwargs) &                                                                                \\
                \hline
            \end{tabular}\caption{Loglevel des Python-Loggers}\label{fig:figure2}}
    \end{figure}
    \\
    Hierbei enthält \texttt{msg} das Format der Zeichenfolge, die die Nachricht hat.
    \texttt{args} sind die Argumente, die in die Nachricht eingefügt werden.
    Der letzte Parameter \texttt{kwargs} kann verschiedene Schlagwörter enthalten:
    \begin{figure}[h]
        \centering
        \textcolor{blue}{
            \begin{itemize}[noitemsep]
                \item exc\_info: falls nicht false, werden die Exception-Informationen den Logs hinzugefügt
                \item stack\_info: default false, falls true wird Stack an Logs angefügt
                \item stacklevel: default 1, falls größer werden dementsprechend viele Stackframes übersprungen
                \item extra: bspw.
                ein Wörterbuch
            \end{itemize}
            \label{fig:}}
    \end{figure}
    \\
    Bei der Methode log wird das Level als statische Funktion angegeben.
    Im Code sieht die Logging-Methode beispielsweise wie folgt aus:
    \\
    \\
    \hspace*{10mm}
    \texttt{d = \{\textquotesingle clientip\textquotesingle : \textquotesingle 193.168.0.1\textquotesingle, \textquotesingle user\textquotesingle: \textquotesingle fbloggs\textquotesingle \}}
    \\
    \hspace*{10mm}
    \texttt{logger = logging.getLogger(\textquotesingle tcpserver\textquotesingle )}
    \\
    \hspace*{10mm}
    \texttt{logger.warning(\textquotesingle Protocol problem: \%s\textquotesingle , \textquotesingle connection reset\textquotesingle ,
        \\
        \hspace*{30mm}
        extra=d)}
    \\
    \\
    Hierdurch entsteht beispielsweise folgende Nachricht, die als Log im Protokoll gespeichert werden kann:
    \\
    \\
    \hspace*{10mm}
    \texttt{2022-06-23 13:19:50,154 192.168.0.1 fbloggs Protocol
    \\
    \hspace*{30mm}
    problem: connection reset}
    \\
}\autocite{docs-python, ionos}

\subsubsection{C++}\label{subsubsec:c++}
\textcolor{blue}{
    In der Standardbibliothek der Programmiersprache C++ ist kein Logger integriert.
    Jedoch ist er leicht zu erstellen und sollte durch ein Interface abgekapselt werden.
    Für ein Interface werden die log-Methoden virtualisiert, je nachdem welche Loglevel genutzt werden sollen.
    Minimal sollten Info, Warn und Error angelegt sein.
}\autocite{c++}

\subsection{Log4J}\label{subsec:log4j}
\textcolor{blue}{
    Bis die Standardbibliothek von Java um einen Logger ergänzt wurde, wurde bereits das Log4J entwickelt.
    Log4J ist ein Open Source Projekt.
    Es wird durch eine Apache Software License verbreitet.
    Log4J ist eine populäre API, weshalb sie in mehrere Sprachen übersetzt wurde.
    Beispielsweise wurde sie in C++ übersetzt, dort heißt die API Log4cxx.
    \\
    Die zentralen Begriffe der API sind Logger, Level, Appender und Layout.
    Logger entspricht dem Zentrum des Interesse.
    Dieser kümmert sich um die Logs.
    Erstellt sie, falls diese dem richtigen Level entsprechen.
    Level ist das Loglevel.
    Der Schwierigkeitsgrad des Ereignisses.
    Falls der Logger das entsprechende Level des Ereignisses hat, soll die Nachricht in das Protokoll geschrieben werden.
    Der Appender kümmert sich um das Anhängen der Ausgabe.
    Falls die Ereignisse in Dateien geschrieben werden, sorgt der Appender dafür, dass die vorher geschriebenen Ereignisse nicht geschrieben werden.
    Layout ist das Format, indem die Nachrichten festgehalten werden, beispielsweise HTML oder XML.
    Das Logging mit Log4J lässt sich über Java Anweisungen konfigurieren.
    Es kann aber auch eine Konfigurationsdatei verwendet werden.
    Mittlerweile ist diese Bibliothek veraltet und dient nur als Grundlage für moderne Nachfolger.\autocite{baeldung, rheinwerk}
\\
\\
Im Zusammenhang mit Log4J wurde durch das Java Naming and Directory Interface (JNDI), welches geschrieben wurde, um Konfigurationsdateien aus dem Internet nachzuladen, eine große Sicherheitslücke geschaffen.
Da Angreifer nun Code, der gefährlich für die Anwendung und das Unternehmen sein kann, einbinden können.
Diese Sicherheitslücke wird Log4Shell bezeichnet und ist die größte Software-Schwachstelle.
Hierbei kann es sein, dass die Angreifer durch ihren Code unbemerkt Brücken gesetzt haben, wodurch sie nicht ausgebessert wurden, als die Sicherheitslücke ausgebessert wurde.
Die Angreifer können sich während der Kontrolle des Systems tot stellen, haben jedoch später die Kontrolle über das System, da Logger meist Adminrechte haben.}\autocite{heise}

\subsection{Log4J2}\label{subsec:log4j2}
\textcolor{blue}{
    Eine Verbesserung dieses Logging-Frameworks ist Log4J2.
    Die größte Verbesserung ist das asynchrone Protokollieren.
    Hierdurch wird das Multithreading möglich und der Logger bleibt in keiner Deadlock, wie es in Log4J1 war.
    Bei eigenständigen Anwendungen ist Log4J2 \enquote{müllfrei}, weshalb der Garbage Collector den Logger nicht entfernt.
    \\
    Durch das Plugin-System ist Log4J2 einfach zu erweitern.
    Beispielsweise einen neuen Appender hinzuzufügen ist einfach, da Log4J nicht verändert werden muss.
    Log4J2 unterstützt für den Appender gewünschte Formate.
    Zum Beispiel Logback kann nur ein bestimmtes Format mit dem Appender transportieren.
}\autocite{log4j2, baeldung}

\subsection{SLF4J}\label{subsec:slf4j}
\textcolor{blue}{
    SLF4J steht für Simple Logging Facade for Java und dient als Fassade für verschiedene Logging-Frameworks.
    Es ist eine einfache API vor einer komplexen Implementierung, beispielsweise dem Logger der Standardbibliothek von Java.
    Interface hilft dabei einfach das Framework zu wechseln.
    \\
    Um diesen Logger zu nutzen, bindet man das Logging-Framework in die pom.xml ein und konfiguriert das Logging wie bei dem genutzten Framework.
    Bei der Nutzung von Log4J2 wird die SLF4J-API genutzt.
    Daher werden drei Dependencies aus org.apache.logging.log4j eingebunden:
    \begin{figure}[h]
        \centering
        \textcolor{blue}{
            \begin{itemize}[noitemsep]
                \item log4j-api
                \item log4j-core
                \item log4j-slf4j-impl
            \end{itemize}\label{fig:figure3}}
    \end{figure}
    \\
    Das Initialisieren des Loggers wird über die LoggerFactory aus dem SLF4J-Paket und als Logger-Objekt gespeichert.
    Weshalb die Import-Anweisungen für die beiden in der nutzenden Klasse gesetzt sein muss:
    \\
    \\
    \hspace*{10mm}
    \texttt{import org.slf4j.Logger;}
    \\
    \hspace*{10mm}
    \texttt{import org.slf4j.LoggerFactory;}
    \\
    \\
    In der Klasse wird der Logger über folgende Zeile definiert.
    \\
    \\
    \hspace*{10mm}
    \texttt{\textbf{private static Logger} logger = LoggerFactory
    \\
    \hspace*{30mm}
    .getLogger(classname.class);}
    \\
    \\
    Bei der Nutzung von Logback muss die SLF4J-Fassade nicht genutzt werden, da Logback bereits die API eingebunden hat.
    \\
    SLF4J bietet weitere Möglichkeiten Logging effizienter zu machen und den Quellcode zu verbessern
    Hierfür werden die Nachrichten nicht durch Strings zusammengesetzt, sondern durch Parameter übergeben, die im Nachhinein eingesetzt werden.
    Hierdurch wird der Parameter, der eingesetzt wird, erst ausgewertet, wenn die Nachricht in die Protokolle aufgenommen werden soll.
    Dadurch wird die Performance wesentlich erhöht.
    Falls dieser Parameter in Log4J erst beim Loggen ausgewertet werden soll, muss ein if-Block um die Methode gesetzt werden, um zu prüfen, ob die Nachricht geloggt werden soll, beispielsweise:
    \\
    \\
    \hspace*{10mm}
    \texttt{\textbf{if}(logger.isDebugEnabled())\{
    \\
    \hspace*{15mm}
    logger.debug(\enquote{Variablenwert: } + variable);
    \\
    \hspace*{10mm}
    \}
    }
}\autocite{baeldung-slf, rheinwerk}

%\subsection{Graylog}\label{subsec:graylog}
%\textcolor{blue}{
%
%}


\section{Tracing}\label{sec:tracing-verfahren}

%\subsection{Jaeger}\label{subsec:jaeger}


\section{Monitoring}\label{sec:monitoring-verfahren}

%\subsection{Grafana}\label{subsec:grafana}
%\subsection{Prometheus}\label{subsec:prometheus}
%\subsection{Argos}\label{subsec:argos}


%\section{Weiterentwicklungen}\label{sec:weiterentwicklungen}

%\section{Performance}\label{sec:performance}